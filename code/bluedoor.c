/*********************************************************************************************
程序名： 　　 宿舍蓝牙门锁控制程序
编写人： 　　 邵国际　
编写时间：　　2015年11月30日
硬件支持：　　STC12C4052AD　外部12MHZ晶振
接口说明：　　详见文件“宿舍蓝牙门锁洞洞板布线图”  
修改日志：
	NO.2-加入开门自动复位（需要增加开关OPEN，关门时接地）　　
　　NO.3-新增功能：门一直开时锁不会复位，只有从门关到门开时才会，并且在门开时Hold住锁不会亮灯
	NO.4-增加开锁口令验证，系统更安全
	NO.5-增加密码输入错误次数大于三次锁定功能，系统更安全
	NO.6-增加对LED指示灯的开关及闪烁操作，更好玩
	NO.7-断开连接时进入空闲模式,不输出PWM,降低功耗(需要蓝牙模块的状态输出)，可由串口中断唤醒
	NO.8-设备连接并超时无数据接收时自动断开蓝牙，防止一人连接后忘断开其他人不可用情况
		（需接一9012三极管控制蓝牙模块电源）
	NO.9-增加门锁状态返回指令，连接时可获取门的状态，便于作出开锁预判（门关着时才开锁）
	NO.10-修改No.8：三极管使蓝牙模块不稳定（宕机啊），无奈拆了三极管，去掉自动断开连接功能，回滚No.7
	NO.11-增加开门数据统计(基于门状态开关),全天候统计开门次数，重新上电时清零
		（修改No.7：由于计数需要使用CPU，不能再使用空闲模式，改为直接关掉定时器0关PWM来省电）
	NO.12-修改PWM定时器初值，使中断间隔为0.05ms，从而实现缓慢松锁（slow_rotate_back）防打扰模式
	NO.13-把在主函数中对指示灯、连接断开、门锁自动复位的代码用函数进行封装，乱中有序
	NO.14-增加外部DS1302时钟芯片,头文件DS1302.h包括了所有与时间有关的操作
	NO.15-增加蜂鸣器忘关门提醒及防盗报警功能
	NO.16-重写对串口字符命令的处理代码，命令以*开始#结束，支持带一个参数，
		  可通过命令调试、设置忘关门提醒检测时间及防盗报警开启时间区间								
/*********************************************************************************************
说明：
用Windows系统中的“超级终端”软件，将串口端设置 [ 4800，8，无，1，无 ]
或采用STC-ISP软件中的串口助手功能，将串口端设置 [ 4800，8，无，1，无 ]

/*********************************************************************************************/
//#include <STC12C2052AD.h>	//STC12C5AxxS2系列单片机头文件
#include <string.h>
#include <DS1302.h>

#define buffer_size 100	  // 串口接收字符缓冲区大小
//#define	OVERTIME 180	  // 连接超时时间（秒）



// 引脚定义
sbit PWM =P1 ^ 6 ;          // PWM信号输出
sbit KEY =P1 ^ 0 ;          // 门状态开关
sbit LED = P1 ^ 5;		  // 指示灯
sbit BLUETOOTH = P1 ^ 4;  // 蓝牙模块连接状态(连接时高电平)
sbit BEEP = P1 ^ 7; 	  // 蜂鸣器

//定义全局变量
xdata unsigned char cmd[50];  // 命令字符串
xdata unsigned char para[50]; // 参数字符串（只能接收一个参数）

// 命令数组，包含所有串口字符串命令
xdata unsigned char *command[21]={
	"unlock",	 	    // 开锁
	"lock",			    // 松锁
    "lighton",			// 开灯
    "lightoff",			// 关灯
	"lightflash",		// 闪灯
	"settime",		    // 设置时间
	"gettime",			// 获取时间
	"setremindtime",	// 设置关门提醒时间
	"getremindtime",	// 获取关门提醒时间
	"setalarmtime",		// 设置报警时间区间
	"getalarmtime",		// 获取报警时间区间
	"getstate",			// 获取门锁状态
	"beepon",	    	// 蜂鸣
	"remindon",			// 开启关门提醒
	"remindoff",		// 关闭关门提醒
	"alarmon",			// 开启防盗报警
	"alarmoff",			// 关闭防盗报警
	"getremind",		// 获取关门提醒是否打开
	"getalarm",			// 获取防盗报警是否打开
	"getcount",			// 获取开门次数
	"clearerro"		    // 清零错误次数
};

// 用来拆命令行命令及参数相关变量
unsigned char separate = 0;
unsigned char cmd_index = 0;
bit cmd_start = 0;
bit cmd_end = 0;

// 开关标志位
bit ALRAMON = 0;             // 报警开关
bit OPEN = 1;				 // 最后状态
bit LIGHT = 0;				 // 常亮
bit FLASH = 0;				 // 闪亮
bit ALARM = 0;				 // 报警状态
bit ALARMON = 1;			 // 报警开关
bit REMINDON = 1;			 // 关门提醒开关
bit RECEIVE = 0;			 // 数据接收标志位

// 使用xdata可解决编译address over flow问题
xdata unsigned char yy,mo,dd,xq,hh,mm,ss;//定义时间映射全局变量（专用寄存器）
xdata unsigned char erro = 0;		 // 口令输入错误次数
xdata int count = 0;                 // 0.5ms定时器1计数数标识
xdata unsigned char angle;           // 角度标识
xdata unsigned char state = 3;	 	 // 串口接收到的舵机状态标识
//xdata int millisecond = 0;		 // 定时器毫秒计时变量（2000为一秒）
//xdata int second = 0;				 // 定时器秒计时变量
xdata int doorCount = 0;			 // 开门次数统计

/*********************************************************************************************
函数名：UART串口初始化函数
调  用：UART_init();
参  数：无
返回值：无
结  果：启动UART串口接收中断，允许串口接收，启动T/C1产生波特率（占用）
备  注：振荡晶体为12MHz，PC串口端设置 [ 4800，8，无，1，无 ]
/**********************************************************************************************/
void UART_init (void){
	EA = 1; //允许总中断（如不使用中断，可用//屏蔽）
	ES = 1; //允许UART串口的中断

	TMOD = 0x21;	//定时器T/C1工作方式2
	SCON = 0x50;	//串口工作方式1，允许串口接收（SCON = 0x40 时禁止串口接收）
	TH1 = 0xF3;	//定时器初值高8位设置
	TL1 = 0xF3;	//定时器初值低8位设置
	PCON = 0x80;	//波特率倍频（屏蔽本句波特率为2400）
	TR1 = 1;	//定时器启动    
}
/**********************************************************************************************/

/*********************************************************************************************
函数名：UART串口发送函数
调  用：UART_T (?);
参  数：需要UART串口发送的数据（8位/1字节）
返回值：无 
结  果：将参数中的数据发送给UART串口，确认发送完成后退出
备  注：
/**********************************************************************************************/
void UART_T (unsigned char UART_data){ //定义串口发送数据变量
	SBUF = UART_data;	//将接收的数据发送回去
	while(TI == 0);		//检查发送中断标志位
	TI = 0;			//令发送中断标志位为0（软件清零）
}
/**********************************************************************************************/

/*********************************************************************************************
函数名：UART串口发送字符串函数
调  用：UART_TC (?);
参  数：需要UART串口发送的数据（8位/1字节）
返回值：无 
结  果：向串口发送一个字符串,长度不限。
备  注：例：UART_TC("d9887321$"); 此函数需要#include <string.h>头文件支持。
/**********************************************************************************************/
void UART_TC (unsigned char *str){
	while(*str != '\0'){
		UART_T(*str);
		*str++;
	}
	*str = 0;
}
/**********************************************************************************************/
/*********************************************************************************************
函数名：毫秒级CPU延时函数
调  用：DELAY_MS (?);
参  数：1~65535（参数不可为0）
返回值：无
结  果：占用CPU方式延时与参数数值相同的毫秒时间
备  注：应用于1T单片机时i<600，应用于12T单片机时i<125
/*********************************************************************************************/
void DELAY_MS (unsigned int a){
	unsigned int i;
	while( a-- != 0){
		for(i = 0; i < 600; i++);
	}
}
/*********************************************************************************************/
/*********************************************************************************************
函数名：舵机旋转函数
调  用：rotate(?);
参  数：1~5（参数不可为0）
返回值：无
结  果：舵机转动到相应的角度
备  注：参数与角度对应关系：1-0度, 2-45度, 3-90度, 4-135度, 5-180度
/*********************************************************************************************/
void rotate(int position)
{
	ET0 = 1; 		  // 开定时器1中断
	angle = position * 10; // 角度赋值
	DELAY_MS(500);	  // 延时等待舵机转动
	ET0 = 0;		  // 关定时器1中断
}
/*********************************************************************************************
函数名：缓慢松锁函数
调  用：slow_rotate(?);
参  数：3（没做大小判断，只能松锁不能开锁）
返回值：无
结  果：舵机缓慢转动到锁门的角度
备  注：
/*********************************************************************************************/
void slow_rotate_back(int position)
{	
	ET0 = 1; 		  // 开定时器1中断
	
	while (angle < position * 10)
	{	
		angle += 1; // 角度赋值
		DELAY_MS(100);
	}

	DELAY_MS(500);	  // 延时等待舵机转动
	ET0 = 0;		  // 关定时器1中断
}
/*********************************************************************************************/
/*********************************************************************************************
函数名：串口命令处理函数
调  用：get_cmd(byte_data) byte_data: SBUF收到的数据
参  数：无
返回值：无
结  果：把串口接收到的字符分隔为一个命令和一个参数，分别存储在cmd和para字符数组中
备  注：参数数组中的数据不会自动清除，需被覆盖
/**********************************************************************************************/
void get_cmd(unsigned char byte_data)
{
 	if (byte_data == '*') { 
		cmd_start = 1;
		cmd_index = 0;
		separate = 0; 
	}
	else if (byte_data == '#') { 
		cmd_start = 0;
		cmd_end = 1;
		if (separate == 1)
			para[cmd_index] = '\0';
		else
		    cmd[cmd_index] = '\0';  
	}
	else if (byte_data == ' ') {
		separate = 1;
		cmd[cmd_index] = '\0';
		cmd_index = 0;	
	}
	else if (cmd_start == 1)
	{
		switch (separate) {
			case 0:
			 	cmd[cmd_index++] = byte_data;
				break;
			case 1:
				para[cmd_index++] = byte_data;
				break;
		}
		
		if (cmd_index >= buffer_size)
			cmd_index = 0;
	}
}
/*********************************************************************************************/
/*********************************************************************************************
函数名：执行命令函数
调  用：do_cmd(int n)
参  数：n 总命令数（命令数组长度）
返回值：无
结  果：遍历命令数组，匹配串口接收到的命令，并执行命令数组中不同命令对应的不同操作
备  注：注意switch-case下标顺序与命令数组顺序对应
/**********************************************************************************************/
void do_cmd(int n)
{
 	int i = 0;

	erro = strcmp(cmd, "clearerro") == 0 ? 0 : erro;  // 清零错误次数命令需独立执行
	  
	for (i = 0; i < n; i++) {
	    if (strcmp(cmd, command[i]) == 0 && erro <= 3) {  // 命令匹配成功且错误次数不大于3
			switch(i) {
			 	case 0:	 state = 1; break;  // 开锁
				case 1:  state = 3; break;  // 松锁
				case 2:  FLASH = 0; LIGHT = 1; LED = 0; break; // 开灯
				case 3:  LIGHT = 0; FLASH = 0; LED = 1; break; // 关灯
				case 4:	 LIGHT = 0; FLASH = 1; break; // 闪灯
				case 5:	 Set_time(para); break;	// 设置时间
				case 6:  UART_TC(Get_time()); break;	 // 获取时间
				case 7:	 Set_remind_time(para); break;  // 设置关门提醒时间
				case 8:	 UART_TC(Get_remind_time()); break; // 获取关门提醒时间
				case 9:  Set_alarm_time(para); break; // 设置报警时间区间					   
				case 10: UART_TC(Get_alarm_time()); break; // 获取报警时间区间
				case 11: UART_T(OPEN ? 0xff : 0x00); break;	// 获取门锁状态				
				case 12: BEEP = 0; break;  // 蜂鸣
				case 13: REMINDON = 1; break;  // 开启关门提醒
				case 14: REMINDON = 0; break;  // 关闭关门提醒
				case 15: ALARMON = 1; break;   // 开启防盗报警
				case 16: ALARMON = 0; break;   // 关闭防盗报警
			    case 17: UART_T(REMINDON ? 0xff : 0x00); break; // 获取关门提醒是否打开
				case 18: UART_T(ALARMON ? 0xff : 0x00); break;	// 获取防盗报警是否打开			
				case 19: UART_T(doorCount / 256); UART_T(doorCount % 256); break; 
				 // 获取开门次数（十六进制，先发送高八位再发送低八位）
				
			}

			cmd[0] = '\0';
			para[0] = '\0';
			
			erro = 0; // 清零错误计数

			break;
		}

	}
	
	if (i == n && RECEIVE)	// 收到的命令不在数组中，错误次数加一
	{
		erro++; 
		RECEIVE = 0;
	} 
}

/*********************************************************************************************/

 /*********************************************************************************************
函数名：UART串口接收中断处理函数
调  用：[SBUF收到数据后中断处理]
参  数：无
返回值：无
结  果：UART串口接收到数据时产生中断，用户对数据进行处理
备  注：过长的处理程序会影响后面数据的接收
/**********************************************************************************************/
void UART_R (void) interrupt 4  using 1{ //切换寄存器组到1
	unsigned char UART_data; //定义串口接收数据变量

	TR0 = 1;		    // 开PWM
//	millisecond = 0;	// 超时清零
//	second = 0;

	ES=0; 				//关串口中断
	RI = 0;				//令接收中断标志位为0（软件清零）
	UART_data = SBUF;	//将接收到的数据送入变量 UART_data

	RECEIVE = 1;		
	get_cmd(UART_data);
	//do_cmd(4);

	ES=1;//开串口中断		
	//SBUF = UART_data;	//将接收的数据发送回去（删除//即生效）
	//while(TI == 0);	//检查发送中断标志位
	//TI = 0;		//令发送中断标志位为0（软件清零）
}	
/**********************************************************************************************/

/*********************************************************************************************
函数名：定时器1初始化函数
调  用：Time0_Init();
参  数：无
返回值：无
结  果：产生0.5ms定时
备  注：无
/*********************************************************************************************/
void Time0_Init()          //定时器初始化
{
	TMOD = 0x21;           //定时器0工作在方式1
	TH0  = 0xFF;
	TL0  = 0xCE;     		//12MZ晶振，0xFE0B(0.5ms)
	EA = 1;					// 开总中断
	ET0 = 1;			   // 开定时器中断
	TR0=1;                 //定时器开始
}
/*********************************************************************************************
函数名：定时器0中断处理函数
调  用：无
参  数：无
返回值：无
结  果：产生周期20ms、占空比0.5~2.5ms高电平的PWM舵机控制信号
备  注：无
/*********************************************************************************************/
void Time0_Int() interrupt 1 //中断程序
{
	TH0  = 0xFF;             //重装初值0xFE0B(0.5ms)
	TL0  = 0xCE;
	
	count++;				 // 累加计数变量

	//if (BLUETOOTH == 1)
	//	millisecond++;
	//if (millisecond == 2000)
	//{
	//	second++;
	//	millisecond = 0;
	//}

	if (count == angle)		 // 高电平结束，占空比调节
		PWM = 0;
	else if (count == 400) {	 // 一个周期
	 	count = 0;
		PWM = 1;
	}

}
/*********************************************************************************************/

/*********************************************************************************************
函数名：门锁上电初始化函数
调  用：无
参  数：无
返回值：无
结  果：无
备  注：程序入口
/*********************************************************************************************/
void door_init()
{
 	//BLUETOOTH = 0;  // 不要初始化拉低，否则拉不高
	//POWER = 0;
	
	// 各种初始化
	UART_init();
	Time0_Init();
	Init_1302();  

	// 指示灯、蜂鸣器初始化
	LED = 1;
	BEEP = 1;

	//Set_1302("2016-04-27-3-23-45-00");

	//Set_time("14-02-50");

	Set_remind_time("00-30-00");
	Set_alarm_time("01-30-00,06-30-00");

	rotate(state);
	DELAY_MS(500); 	// 等待舵机位置初始化
	//PCON = 0x81;
}
/*********************************************************************************************/

/*********************************************************************************************
函数名：蓝牙连接断开处理函数
调  用：dis_bluetooth()
参  数：无
返回值：无
结  果：在蓝牙模块断开连接时进行相应操作
备  注：
/*********************************************************************************************/
void dis_bluetooth()
{
 	if (!BLUETOOTH)	    // 蓝牙连接断开
	{
		LED = 1;        // 关指示灯
		BEEP = 1;		// 关蜂鸣器
		LIGHT = 0;		// 清零常亮标志位
		FLASH = 0;		// 清零闪亮标志位

		state = 3;	    // 舵机角度复位（松锁）
		//rotate(state);
		slow_rotate_back(state);  // 舵机缓慢归位
		DELAY_MS(500); 	// 等待舵机位置

		TR0 = 0;		// 关PWM
		//PCON = 0x81;  // 进入空闲模式

	}
}
/*********************************************************************************************/

/*********************************************************************************************
函数名：门锁复位函数
调  用：auto_back
参  数：无
返回值：无
结  果：开门后门锁自动复位
备  注：
/*********************************************************************************************/
void auto_back()
{			
	if (KEY != 0 && OPEN == 0) // 关门到开门的过程
	{
		state = 3; 		// 开门后门锁自动复位
		OPEN = 1;
		doorCount++;	// 开门次数统计
	}
	else
	{
		OPEN = KEY;		// 刷新门状态
	}
}

/*********************************************************************************************
函数名：指示灯处理函数
调  用：do_light()
参  数：无
返回值：无
结  果：对指示灯进行处理
备  注：
/*********************************************************************************************/
void do_light()
{
	if (state == 1 && OPEN == 0 && LIGHT == 0)	 // 开锁且无手动开灯时亮灯
		LED = 0;			
	else if (LIGHT == 0)  // 无手动开灯时灭灯		
		LED = 1;
		
	if (FLASH == 1)	  // 闪烁灯
	{
	 	LED = 0;
		DELAY_MS(100);
		LED = 1;
		DELAY_MS(100);			
	}

}
/*********************************************************************************************/
/*********************************************************************************************
函数名：忘关门提醒函数
调  用：Time_remind()
参  数：无
返回值：无
结  果：在设定的提醒时间时若未关门则蜂鸣提醒
备  注：一分钟之内关门蜂鸣器会停止鸣叫
/*********************************************************************************************/
 void Time_remind()
 {
 	unsigned char rh, rm, rs;
	unsigned char *time = Get_remind_time();

	rh = ((time[0] - 0x30) * 16) + (time[1] - 0x30);
	rm = ((time[3] - 0x30) * 16) + (time[4] - 0x30);
	rs = ((time[6] - 0x30) * 16) + (time[7] - 0x30);

	if (hh == rh && mm == rm && REMINDON) // 到指定时间
	{
		if (KEY != 0 && ss % 5 == 0)	// 门没关（ss % 5 == 0产生5s间接鸣叫）	
			ALARM = 1;  // 蜂鸣提醒一分钟
		else
			ALARM = 0;		
	}
	
 }

/**********************************************************************************************/

/*********************************************************************************************
函数名：防盗报警函数
调  用：Time_alarm()
参  数：无
返回值：无
结  果：在设定的提醒时间区间内若门状态为开则蜂鸣报警
备  注：一旦报警即使把门关上蜂鸣器也不会停止鸣叫
/*********************************************************************************************/
 void Time_alarm()
 {
 	unsigned char ah1, am1, as1;   // 防盗起始时间
	unsigned char ah2, am2, as2;   // 防盗结束时间

	unsigned char *time = Get_alarm_time();

	ah1 = ((time[0] - 0x30) * 16) + (time[1] - 0x30);
	am1 = ((time[3] - 0x30) * 16) + (time[4] - 0x30);
	as1 = ((time[6] - 0x30) * 16) + (time[7] - 0x30);

	ah2 = ((time[9] - 0x30) * 16) + (time[10] - 0x30);
	am2 = ((time[12] - 0x30) * 16) + (time[13] - 0x30);
	as2 = ((time[15] - 0x30) * 16) + (time[16] - 0x30);

	if (hh >= ah1 && hh <= ah2 && mm >= am1 && mm <= am2 && KEY != 0 && ALARMON) // 报警时间区间内门没关	 	
		ALARM = 1;  // 蜂鸣报警	

 }

/**********************************************************************************************/
/*********************************************************************************************
函数名：主函数
调  用：无
参  数：无
返回值：无
结  果：无
备  注：程序入口
/*********************************************************************************************/

void main()
{
	DELAY_MS(500);	// 等待串口连接断开
   	P3M1 = 0x38;
	door_init();	// 门锁初始化

	while(1)
	{		
		rotate(state);		// 执行舵机转动

		dis_bluetooth();	// 蓝牙连接断开处理
		auto_back();		// 门锁自动复位
		do_light();			// 处理指示灯

		Time_remind();		// 忘关门提醒检测
		Time_alarm();		// 防盗报警检测

		read_clockS(&yy,&mo,&dd,&xq,&hh,&mm,&ss);  // 更新时间
				
		BEEP = ~ALARM;		// 刷新蜂鸣器状态

		do_cmd(21);	   		// 执行串口收到的字符串命令

		/*
		if (second > OVERTIME && BLUETOOTH == 1)	// 超时处理
		{
			POWER = 1;
			DELAY_MS(1000);		 // 蓝牙模块重新上电，断开连接
			POWER = 0;
			second = 0;
		}
		*/
							
	}
}
