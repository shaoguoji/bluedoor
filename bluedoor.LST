C51 COMPILER V9.00   BLUEDOOR                                                              05/11/2016 15:56:41 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE BLUEDOOR
OBJECT MODULE PLACED IN bluedoor.OBJ
COMPILER INVOKED BY: F:\Program Files\Keil\C51\BIN\C51.EXE bluedoor.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /*********************************************************************************************
   2          程序名： 　　 宿舍蓝牙门锁控制程序
   3          编写人： 　　 邵国际　
   4          编写时间：　　2015年11月30日
   5          硬件支持：　　STC12C4052AD　外部12MHZ晶振
   6          接口说明：　　详见文件“宿舍蓝牙门锁洞洞板布线图”  
   7          修改日志：
   8                  NO.2-加入开门自动复位（需要增加开关OPEN，关门时接地）　　
   9          　　NO.3-新增功能：门一直开时锁不会复位，只有从门关到门开时才会，并且在门开时Hold住锁不会亮灯
  10                  NO.4-增加开锁口令验证，系统更安全
  11                  NO.5-增加密码输入错误次数大于三次锁定功能，系统更安全
  12                  NO.6-增加对LED指示灯的开关及闪烁操作，更好玩
  13                  NO.7-断开连接时进入空闲模式,不输出PWM,降低功耗(需要蓝牙模块的状态输出)，可由串口中断唤醒
  14                  NO.8-设备连接并超时无数据接收时自动断开蓝牙，防止一人连接后忘断开其他人不可用情况
  15                          （需接一9012三极管控制蓝牙模块电源）
  16                  NO.9-增加门锁状态返回指令，连接时可获取门的状态，便于作出开锁预判（门关着时才开锁）
  17                  NO.10-修改No.8：三极管使蓝牙模块不稳定（宕机啊），无奈拆了三极管，去掉自动断开连接功能，回滚No.7
  18                  NO.11-增加开门数据统计(基于门状态开关),全天候统计开门次数，重新上电时清零
  19                          （修改No.7：由于计数需要使用CPU，不能再使用空闲模式，改为直接关掉定时器0关PWM来省电）
  20                  NO.12-修改PWM定时器初值，使中断间隔为0.05ms，从而实现缓慢松锁（slow_rotate_back）防打扰模式
  21                  NO.13-把在主函数中对指示灯、连接断开、门锁自动复位的代码用函数进行封装，乱中有序
  22                  NO.14-增加外部DS1302时钟芯片,头文件DS1302.h包括了所有与时间有关的操作
  23                  NO.15-增加蜂鸣器忘关门提醒及防盗报警功能
  24                  NO.16-重写对串口字符命令的处理代码，命令以*开始#结束，支持带一个参数，
  25                            可通过命令调试、设置忘关门提醒检测时间及防盗报警开启时间区间                                                          
  26          /*********************************************************************************************
  27          说明：
  28          用Windows系统中的“超级终端”软件，将串口端设置 [ 4800，8，无，1，无 ]
  29          或采用STC-ISP软件中的串口助手功能，将串口端设置 [ 4800，8，无，1，无 ]
  30          
  31          /*********************************************************************************************/
  32          //#include <STC12C2052AD.h>     //STC12C5AxxS2系列单片机头文件
  33          #include <string.h>
  34          #include <DS1302.h>
  35          
  36          #define buffer_size 100   // 串口接收字符缓冲区大小
  37          //#define       OVERTIME 180      // 连接超时时间（秒）
  38          
  39          
  40          
  41          // 引脚定义
  42          sbit PWM =P1 ^ 6 ;          // PWM信号输出
  43          sbit KEY =P1 ^ 0 ;          // 门状态开关
  44          sbit LED = P1 ^ 5;                // 指示灯
  45          sbit BLUETOOTH = P1 ^ 4;  // 蓝牙模块连接状态(连接时高电平)
  46          sbit BEEP = P1 ^ 7;       // 蜂鸣器
  47          
  48          //定义全局变量
  49          xdata unsigned char cmd[50];  // 命令字符串
  50          xdata unsigned char para[50]; // 参数字符串（只能接收一个参数）
  51          
  52          // 命令数组，包含所有串口字符串命令
  53          xdata unsigned char *command[21]={
  54                  "unlock",                   // 开锁
  55                  "lock",                     // 松锁
C51 COMPILER V9.00   BLUEDOOR                                                              05/11/2016 15:56:41 PAGE 2   

  56              "lighton",                  // 开灯
  57              "lightoff",                 // 关灯
  58                  "lightflash",           // 闪灯
  59                  "settime",                  // 设置时间
  60                  "gettime",                      // 获取时间
  61                  "setremindtime",        // 设置关门提醒时间
  62                  "getremindtime",        // 获取关门提醒时间
  63                  "setalarmtime",         // 设置报警时间区间
  64                  "getalarmtime",         // 获取报警时间区间
  65                  "getstate",                     // 获取门锁状态
  66                  "beepon",               // 蜂鸣
  67                  "remindon",                     // 开启关门提醒
  68                  "remindoff",            // 关闭关门提醒
  69                  "alarmon",                      // 开启防盗报警
  70                  "alarmoff",                     // 关闭防盗报警
  71                  "getremind",            // 获取关门提醒是否打开
  72                  "getalarm",                     // 获取防盗报警是否打开
  73                  "getcount",                     // 获取开门次数
  74                  "clearerro"                 // 清零错误次数
  75          };
  76          
  77          // 用来拆命令行命令及参数相关变量
  78          unsigned char separate = 0;
  79          unsigned char cmd_index = 0;
  80          bit cmd_start = 0;
  81          bit cmd_end = 0;
  82          
  83          // 开关标志位
  84          bit ALRAMON = 0;             // 报警开关
  85          bit OPEN = 1;                            // 最后状态
  86          bit LIGHT = 0;                           // 常亮
  87          bit FLASH = 0;                           // 闪亮
  88          bit ALARM = 0;                           // 报警状态
  89          bit ALARMON = 1;                         // 报警开关
  90          bit REMINDON = 1;                        // 关门提醒开关
  91          bit RECEIVE = 0;                         // 数据接收标志位
  92          
  93          // 使用xdata可解决编译address over flow问题
  94          xdata unsigned char yy,mo,dd,xq,hh,mm,ss;//定义时间映射全局变量（专用寄存器）
  95          xdata unsigned char erro = 0;            // 口令输入错误次数
  96          xdata int count = 0;                 // 0.5ms定时器1计数数标识
  97          xdata unsigned char angle;           // 角度标识
  98          xdata unsigned char state = 3;           // 串口接收到的舵机状态标识
  99          //xdata int millisecond = 0;             // 定时器毫秒计时变量（2000为一秒）
 100          //xdata int second = 0;                          // 定时器秒计时变量
 101          xdata int doorCount = 0;                         // 开门次数统计
 102          
 103          /*********************************************************************************************
 104          函数名：UART串口初始化函数
 105          调  用：UART_init();
 106          参  数：无
 107          返回值：无
 108          结  果：启动UART串口接收中断，允许串口接收，启动T/C1产生波特率（占用）
 109          备  注：振荡晶体为12MHz，PC串口端设置 [ 4800，8，无，1，无 ]
 110          /**********************************************************************************************/
 111          void UART_init (void){
 112   1              EA = 1; //允许总中断（如不使用中断，可用//屏蔽）
 113   1              ES = 1; //允许UART串口的中断
 114   1      
 115   1              TMOD = 0x21;    //定时器T/C1工作方式2
 116   1              SCON = 0x50;    //串口工作方式1，允许串口接收（SCON = 0x40 时禁止串口接收）
 117   1              TH1 = 0xF3;     //定时器初值高8位设置
C51 COMPILER V9.00   BLUEDOOR                                                              05/11/2016 15:56:41 PAGE 3   

 118   1              TL1 = 0xF3;     //定时器初值低8位设置
 119   1              PCON = 0x80;    //波特率倍频（屏蔽本句波特率为2400）
 120   1              TR1 = 1;        //定时器启动    
 121   1      }
 122          /**********************************************************************************************/
 123          
 124          /*********************************************************************************************
 125          函数名：UART串口发送函数
 126          调  用：UART_T (?);
 127          参  数：需要UART串口发送的数据（8位/1字节）
 128          返回值：无 
 129          结  果：将参数中的数据发送给UART串口，确认发送完成后退出
 130          备  注：
 131          /**********************************************************************************************/
 132          void UART_T (unsigned char UART_data){ //定义串口发送数据变量
 133   1              SBUF = UART_data;       //将接收的数据发送回去
 134   1              while(TI == 0);         //检查发送中断标志位
 135   1              TI = 0;                 //令发送中断标志位为0（软件清零）
 136   1      }
 137          /**********************************************************************************************/
 138          
 139          /*********************************************************************************************
 140          函数名：UART串口发送字符串函数
 141          调  用：UART_TC (?);
 142          参  数：需要UART串口发送的数据（8位/1字节）
 143          返回值：无 
 144          结  果：向串口发送一个字符串,长度不限。
 145          备  注：例：UART_TC("d9887321$"); 此函数需要#include <string.h>头文件支持。
 146          /**********************************************************************************************/
 147          void UART_TC (unsigned char *str){
 148   1              while(*str != '\0'){
 149   2                      UART_T(*str);
 150   2                      *str++;
*** WARNING C275 IN LINE 150 OF BLUEDOOR.C: expression with possibly no effect
 151   2              }
 152   1              *str = 0;
 153   1      }
 154          /**********************************************************************************************/
 155          /*********************************************************************************************
 156          函数名：毫秒级CPU延时函数
 157          调  用：DELAY_MS (?);
 158          参  数：1~65535（参数不可为0）
 159          返回值：无
 160          结  果：占用CPU方式延时与参数数值相同的毫秒时间
 161          备  注：应用于1T单片机时i<600，应用于12T单片机时i<125
 162          /*********************************************************************************************/
 163          void DELAY_MS (unsigned int a){
 164   1              unsigned int i;
 165   1              while( a-- != 0){
 166   2                      for(i = 0; i < 600; i++);
 167   2              }
 168   1      }
 169          /*********************************************************************************************/
 170          /*********************************************************************************************
 171          函数名：舵机旋转函数
 172          调  用：rotate(?);
 173          参  数：1~5（参数不可为0）
 174          返回值：无
 175          结  果：舵机转动到相应的角度
 176          备  注：参数与角度对应关系：1-0度, 2-45度, 3-90度, 4-135度, 5-180度
 177          /*********************************************************************************************/
 178          void rotate(int position)
C51 COMPILER V9.00   BLUEDOOR                                                              05/11/2016 15:56:41 PAGE 4   

 179          {
 180   1              ET0 = 1;                  // 开定时器1中断
 181   1              angle = position * 10; // 角度赋值
 182   1              DELAY_MS(500);    // 延时等待舵机转动
 183   1              ET0 = 0;                  // 关定时器1中断
 184   1      }
 185          /*********************************************************************************************
 186          函数名：缓慢松锁函数
 187          调  用：slow_rotate(?);
 188          参  数：3（没做大小判断，只能松锁不能开锁）
 189          返回值：无
 190          结  果：舵机缓慢转动到锁门的角度
 191          备  注：
 192          /*********************************************************************************************/
 193          void slow_rotate_back(int position)
 194          {       
 195   1              ET0 = 1;                  // 开定时器1中断
 196   1              
 197   1              while (angle < position * 10)
 198   1              {       
 199   2                      angle += 1; // 角度赋值
 200   2                      DELAY_MS(100);
 201   2              }
 202   1      
 203   1              DELAY_MS(500);    // 延时等待舵机转动
 204   1              ET0 = 0;                  // 关定时器1中断
 205   1      }
 206          /*********************************************************************************************/
 207          /*********************************************************************************************
 208          函数名：串口命令处理函数
 209          调  用：get_cmd(byte_data) byte_data: SBUF收到的数据
 210          参  数：无
 211          返回值：无
 212          结  果：把串口接收到的字符分隔为一个命令和一个参数，分别存储在cmd和para字符数组中
 213          备  注：参数数组中的数据不会自动清除，需被覆盖
 214          /**********************************************************************************************/
 215          void get_cmd(unsigned char byte_data)
 216          {
 217   1              if (byte_data == '*') { 
 218   2                      cmd_start = 1;
 219   2                      cmd_index = 0;
 220   2                      separate = 0; 
 221   2              }
 222   1              else if (byte_data == '#') { 
 223   2                      cmd_start = 0;
 224   2                      cmd_end = 1;
 225   2                      if (separate == 1)
 226   2                              para[cmd_index] = '\0';
 227   2                      else
 228   2                          cmd[cmd_index] = '\0';  
 229   2              }
 230   1              else if (byte_data == ' ') {
 231   2                      separate = 1;
 232   2                      cmd[cmd_index] = '\0';
 233   2                      cmd_index = 0;  
 234   2              }
 235   1              else if (cmd_start == 1)
 236   1              {
 237   2                      switch (separate) {
 238   3                              case 0:
 239   3                                      cmd[cmd_index++] = byte_data;
 240   3                                      break;
C51 COMPILER V9.00   BLUEDOOR                                                              05/11/2016 15:56:41 PAGE 5   

 241   3                              case 1:
 242   3                                      para[cmd_index++] = byte_data;
 243   3                                      break;
 244   3                      }
 245   2                      
 246   2                      if (cmd_index >= buffer_size)
 247   2                              cmd_index = 0;
 248   2              }
 249   1      }
 250          /*********************************************************************************************/
 251          /*********************************************************************************************
 252          函数名：执行命令函数
 253          调  用：do_cmd(int n)
 254          参  数：n 总命令数（命令数组长度）
 255          返回值：无
 256          结  果：遍历命令数组，匹配串口接收到的命令，并执行命令数组中不同命令对应的不同操作
 257          备  注：注意switch-case下标顺序与命令数组顺序对应
 258          /**********************************************************************************************/
 259          void do_cmd(int n)
 260          {
 261   1              int i = 0;
 262   1      
 263   1              erro = strcmp(cmd, "clearerro") == 0 ? 0 : erro;  // 清零错误次数命令需独立执行
 264   1                
 265   1              for (i = 0; i < n; i++) {
 266   2                  if (strcmp(cmd, command[i]) == 0 && erro <= 3) {  // 命令匹配成功且错误次数不大于3
 267   3                              switch(i) {
 268   4                                      case 0:  state = 1; break;  // 开锁
 269   4                                      case 1:  state = 3; break;  // 松锁
 270   4                                      case 2:  FLASH = 0; LIGHT = 1; LED = 0; break; // 开灯
 271   4                                      case 3:  LIGHT = 0; FLASH = 0; LED = 1; break; // 关灯
 272   4                                      case 4:  LIGHT = 0; FLASH = 1; break; // 闪灯
 273   4                                      case 5:  Set_time(para); break; // 设置时间
 274   4                                      case 6:  UART_TC(Get_time()); break;     // 获取时间
 275   4                                      case 7:  Set_remind_time(para); break;  // 设置关门提醒时间
 276   4                                      case 8:  UART_TC(Get_remind_time()); break; // 获取关门提醒时间
 277   4                                      case 9:  Set_alarm_time(para); break; // 设置报警时间区间                                          
 278   4                                      case 10: UART_TC(Get_alarm_time()); break; // 获取报警时间区间
 279   4                                      case 11: UART_T(OPEN ? 0xff : 0x00); break;     // 获取门锁状态                         
 280   4                                      case 12: BEEP = 0; break;  // 蜂鸣
 281   4                                      case 13: REMINDON = 1; break;  // 开启关门提醒
 282   4                                      case 14: REMINDON = 0; break;  // 关闭关门提醒
 283   4                                      case 15: ALARMON = 1; break;   // 开启防盗报警
 284   4                                      case 16: ALARMON = 0; break;   // 关闭防盗报警
 285   4                                  case 17: UART_T(REMINDON ? 0xff : 0x00); break; // 获取关门提醒是否打开
 286   4                                      case 18: UART_T(ALARMON ? 0xff : 0x00); break;  // 获取防盗报警是否打开                 
 287   4                                      case 19: UART_T(doorCount / 256); UART_T(doorCount % 256); break; 
 288   4                                       // 获取开门次数（十六进制，先发送高八位再发送低八位）
 289   4                                      
 290   4                              }
 291   3      
 292   3                              cmd[0] = '\0';
 293   3                              para[0] = '\0';
 294   3                              
 295   3                              erro = 0; // 清零错误计数
 296   3      
 297   3                              break;
 298   3                      }
 299   2      
 300   2              }
 301   1              
 302   1              if (i == n && RECEIVE)  // 收到的命令不在数组中，错误次数加一
C51 COMPILER V9.00   BLUEDOOR                                                              05/11/2016 15:56:41 PAGE 6   

 303   1              {
 304   2                      erro++; 
 305   2                      RECEIVE = 0;
 306   2              } 
 307   1      }
 308          
 309          /*********************************************************************************************/
 310          
 311           /*********************************************************************************************
 312          函数名：UART串口接收中断处理函数
 313          调  用：[SBUF收到数据后中断处理]
 314          参  数：无
 315          返回值：无
 316          结  果：UART串口接收到数据时产生中断，用户对数据进行处理
 317          备  注：过长的处理程序会影响后面数据的接收
 318          /**********************************************************************************************/
 319          void UART_R (void) interrupt 4  using 1{ //切换寄存器组到1
 320   1              unsigned char UART_data; //定义串口接收数据变量
 321   1      
 322   1              TR0 = 1;                    // 开PWM
 323   1      //      millisecond = 0;        // 超时清零
 324   1      //      second = 0;
 325   1      
 326   1              ES=0;                           //关串口中断
 327   1              RI = 0;                         //令接收中断标志位为0（软件清零）
 328   1              UART_data = SBUF;       //将接收到的数据送入变量 UART_data
 329   1      
 330   1              RECEIVE = 1;            
 331   1              get_cmd(UART_data);
 332   1              //do_cmd(4);
 333   1      
 334   1              ES=1;//开串口中断               
 335   1              //SBUF = UART_data;     //将接收的数据发送回去（删除//即生效）
 336   1              //while(TI == 0);       //检查发送中断标志位
 337   1              //TI = 0;               //令发送中断标志位为0（软件清零）
 338   1      }       
 339          /**********************************************************************************************/
 340          
 341          /*********************************************************************************************
 342          函数名：定时器1初始化函数
 343          调  用：Time0_Init();
 344          参  数：无
 345          返回值：无
 346          结  果：产生0.5ms定时
 347          备  注：无
 348          /*********************************************************************************************/
 349          void Time0_Init()          //定时器初始化
 350          {
 351   1              TMOD = 0x21;           //定时器0工作在方式1
 352   1              TH0  = 0xFF;
 353   1              TL0  = 0xCE;                    //12MZ晶振，0xFE0B(0.5ms)
 354   1              EA = 1;                                 // 开总中断
 355   1              ET0 = 1;                           // 开定时器中断
 356   1              TR0=1;                 //定时器开始
 357   1      }
 358          /*********************************************************************************************
 359          函数名：定时器0中断处理函数
 360          调  用：无
 361          参  数：无
 362          返回值：无
 363          结  果：产生周期20ms、占空比0.5~2.5ms高电平的PWM舵机控制信号
 364          备  注：无
C51 COMPILER V9.00   BLUEDOOR                                                              05/11/2016 15:56:41 PAGE 7   

 365          /*********************************************************************************************/
 366          void Time0_Int() interrupt 1 //中断程序
 367          {
 368   1              TH0  = 0xFF;             //重装初值0xFE0B(0.5ms)
 369   1              TL0  = 0xCE;
 370   1              
 371   1              count++;                                 // 累加计数变量
 372   1      
 373   1              //if (BLUETOOTH == 1)
 374   1              //      millisecond++;
 375   1              //if (millisecond == 2000)
 376   1              //{
 377   1              //      second++;
 378   1              //      millisecond = 0;
 379   1              //}
 380   1      
 381   1              if (count == angle)              // 高电平结束，占空比调节
 382   1                      PWM = 0;
 383   1              else if (count == 400) {         // 一个周期
 384   2                      count = 0;
 385   2                      PWM = 1;
 386   2              }
 387   1      
 388   1      }
 389          /*********************************************************************************************/
 390          
 391          /*********************************************************************************************
 392          函数名：门锁上电初始化函数
 393          调  用：无
 394          参  数：无
 395          返回值：无
 396          结  果：无
 397          备  注：程序入口
 398          /*********************************************************************************************/
 399          void door_init()
 400          {
 401   1              //BLUETOOTH = 0;  // 不要初始化拉低，否则拉不高
 402   1              //POWER = 0;
 403   1              
 404   1              // 各种初始化
 405   1              UART_init();
 406   1              Time0_Init();
 407   1              Init_1302();  
 408   1      
 409   1              // 指示灯、蜂鸣器初始化
 410   1              LED = 1;
 411   1              BEEP = 1;
 412   1      
 413   1              //Set_1302("2016-04-27-3-23-45-00");
 414   1      
 415   1              //Set_time("14-02-50");
 416   1      
 417   1              Set_remind_time("00-30-00");
 418   1              Set_alarm_time("01-30-00,06-30-00");
 419   1      
 420   1              rotate(state);
 421   1              DELAY_MS(500);  // 等待舵机位置初始化
 422   1              //PCON = 0x81;
 423   1      }
 424          /*********************************************************************************************/
 425          
 426          /*********************************************************************************************
C51 COMPILER V9.00   BLUEDOOR                                                              05/11/2016 15:56:41 PAGE 8   

 427          函数名：蓝牙连接断开处理函数
 428          调  用：dis_bluetooth()
 429          参  数：无
 430          返回值：无
 431          结  果：在蓝牙模块断开连接时进行相应操作
 432          备  注：
 433          /*********************************************************************************************/
 434          void dis_bluetooth()
 435          {
 436   1              if (!BLUETOOTH)     // 蓝牙连接断开
 437   1              {
 438   2                      LED = 1;        // 关指示灯
 439   2                      BEEP = 1;               // 关蜂鸣器
 440   2                      LIGHT = 0;              // 清零常亮标志位
 441   2                      FLASH = 0;              // 清零闪亮标志位
 442   2      
 443   2                      state = 3;          // 舵机角度复位（松锁）
 444   2                      //rotate(state);
 445   2                      slow_rotate_back(state);  // 舵机缓慢归位
 446   2                      DELAY_MS(500);  // 等待舵机位置
 447   2      
 448   2                      TR0 = 0;                // 关PWM
 449   2                      //PCON = 0x81;  // 进入空闲模式
 450   2      
 451   2              }
 452   1      }
 453          /*********************************************************************************************/
 454          
 455          /*********************************************************************************************
 456          函数名：门锁复位函数
 457          调  用：auto_back
 458          参  数：无
 459          返回值：无
 460          结  果：开门后门锁自动复位
 461          备  注：
 462          /*********************************************************************************************/
 463          void auto_back()
 464          {                       
 465   1              if (KEY != 0 && OPEN == 0) // 关门到开门的过程
 466   1              {
 467   2                      state = 3;              // 开门后门锁自动复位
 468   2                      OPEN = 1;
 469   2                      doorCount++;    // 开门次数统计
 470   2              }
 471   1              else
 472   1              {
 473   2                      OPEN = KEY;             // 刷新门状态
 474   2              }
 475   1      }
 476          
 477          /*********************************************************************************************
 478          函数名：指示灯处理函数
 479          调  用：do_light()
 480          参  数：无
 481          返回值：无
 482          结  果：对指示灯进行处理
 483          备  注：
 484          /*********************************************************************************************/
 485          void do_light()
 486          {
 487   1              if (state == 1 && OPEN == 0 && LIGHT == 0)       // 开锁且无手动开灯时亮灯
 488   1                      LED = 0;                        
C51 COMPILER V9.00   BLUEDOOR                                                              05/11/2016 15:56:41 PAGE 9   

 489   1              else if (LIGHT == 0)  // 无手动开灯时灭灯               
 490   1                      LED = 1;
 491   1                      
 492   1              if (FLASH == 1)   // 闪烁灯
 493   1              {
 494   2                      LED = 0;
 495   2                      DELAY_MS(100);
 496   2                      LED = 1;
 497   2                      DELAY_MS(100);                  
 498   2              }
 499   1      
 500   1      }
 501          /*********************************************************************************************/
 502          /*********************************************************************************************
 503          函数名：忘关门提醒函数
 504          调  用：Time_remind()
 505          参  数：无
 506          返回值：无
 507          结  果：在设定的提醒时间时若未关门则蜂鸣提醒
 508          备  注：一分钟之内关门蜂鸣器会停止鸣叫
 509          /*********************************************************************************************/
 510           void Time_remind()
 511           {
 512   1              unsigned char rh, rm, rs;
 513   1              unsigned char *time = Get_remind_time();
 514   1      
 515   1              rh = ((time[0] - 0x30) * 16) + (time[1] - 0x30);
 516   1              rm = ((time[3] - 0x30) * 16) + (time[4] - 0x30);
 517   1              rs = ((time[6] - 0x30) * 16) + (time[7] - 0x30);
 518   1      
 519   1              if (hh == rh && mm == rm && REMINDON) // 到指定时间
 520   1              {
 521   2                      if (KEY != 0 && ss % 5 == 0)    // 门没关（ss % 5 == 0产生5s间接鸣叫）  
 522   2                              ALARM = 1;  // 蜂鸣提醒一分钟
 523   2                      else
 524   2                              ALARM = 0;              
 525   2              }
 526   1              
 527   1       }
 528          
 529          /**********************************************************************************************/
 530          
 531          /*********************************************************************************************
 532          函数名：防盗报警函数
 533          调  用：Time_alarm()
 534          参  数：无
 535          返回值：无
 536          结  果：在设定的提醒时间区间内若门状态为开则蜂鸣报警
 537          备  注：一旦报警即使把门关上蜂鸣器也不会停止鸣叫
 538          /*********************************************************************************************/
 539           void Time_alarm()
 540           {
 541   1              unsigned char ah1, am1, as1;   // 防盗起始时间
 542   1              unsigned char ah2, am2, as2;   // 防盗结束时间
 543   1      
 544   1              unsigned char *time = Get_alarm_time();
 545   1      
 546   1              ah1 = ((time[0] - 0x30) * 16) + (time[1] - 0x30);
 547   1              am1 = ((time[3] - 0x30) * 16) + (time[4] - 0x30);
 548   1              as1 = ((time[6] - 0x30) * 16) + (time[7] - 0x30);
 549   1      
 550   1              ah2 = ((time[9] - 0x30) * 16) + (time[10] - 0x30);
C51 COMPILER V9.00   BLUEDOOR                                                              05/11/2016 15:56:41 PAGE 10  

 551   1              am2 = ((time[12] - 0x30) * 16) + (time[13] - 0x30);
 552   1              as2 = ((time[15] - 0x30) * 16) + (time[16] - 0x30);
 553   1      
 554   1              if (hh >= ah1 && hh <= ah2 && mm >= am1 && mm <= am2 && KEY != 0 && ALARMON) // 报警时间区间内门没关            
 555   1                      ALARM = 1;  // 蜂鸣报警 
 556   1      
 557   1       }
 558          
 559          /**********************************************************************************************/
 560          /*********************************************************************************************
 561          函数名：主函数
 562          调  用：无
 563          参  数：无
 564          返回值：无
 565          结  果：无
 566          备  注：程序入口
 567          /*********************************************************************************************/
 568          
 569          void main()
 570          {
 571   1              DELAY_MS(500);  // 等待串口连接断开
 572   1              P3M1 = 0x38;
 573   1              door_init();    // 门锁初始化
 574   1      
 575   1              while(1)
 576   1              {               
 577   2                      rotate(state);          // 执行舵机转动
 578   2      
 579   2                      dis_bluetooth();        // 蓝牙连接断开处理
 580   2                      auto_back();            // 门锁自动复位
 581   2                      do_light();                     // 处理指示灯
 582   2      
 583   2                      Time_remind();          // 忘关门提醒检测
 584   2                      Time_alarm();           // 防盗报警检测
 585   2      
 586   2                      read_clockS(&yy,&mo,&dd,&xq,&hh,&mm,&ss);  // 更新时间
 587   2                                      
 588   2                      BEEP = ~ALARM;          // 刷新蜂鸣器状态
 589   2      
 590   2                      do_cmd(21);                     // 执行串口收到的字符串命令
 591   2      
 592   2                      /*
 593   2                      if (second > OVERTIME && BLUETOOTH == 1)        // 超时处理
 594   2                      {
 595   2                              POWER = 1;
 596   2                              DELAY_MS(1000);          // 蓝牙模块重新上电，断开连接
 597   2                              POWER = 0;
 598   2                              second = 0;
 599   2                      }
 600   2                      */
 601   2                                                              
 602   2              }
 603   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2679    ----
   CONSTANT SIZE    =    227    ----
   XDATA SIZE       =    177    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      2      83
   IDATA SIZE       =   ----    ----
C51 COMPILER V9.00   BLUEDOOR                                                              05/11/2016 15:56:41 PAGE 11  

   BIT SIZE         =     10    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
